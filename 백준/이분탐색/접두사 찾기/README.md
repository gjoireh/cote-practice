### 문제

문자열 S의 접두사란 S의 가장 앞에서부터 부분 문자열을 의미한다. 예를 들어, S = "codeplus"의 접두사는 "code", "co", "codepl", "codeplus"가 있고, "plus", "s", "cude", "crud"는 접두사가 아니다.

총 N개의 문자열로 이루어진 집합 S가 주어진다.

입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 문자열 중 적어도 하나의 접두사인 것의 개수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 문자열의 개수 N과 M (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000)이 주어진다. 

다음 N개의 줄에는 집합 S에 포함되어 있는 문자열이 주어진다.

다음 M개의 줄에는 검사해야 하는 문자열이 주어진다.

입력으로 주어지는 문자열은 알파벳 소문자로만 이루어져 있으며, 길이는 500을 넘지 않는다. 집합 S에 같은 문자열이 여러 번 주어지는 경우는 없다. 

### 출력

첫째 줄에 M개의 문자열 중에 총 몇 개가 포함되어 있는 문자열 중 적어도 하나의 접두사인지 출력한다.

### 예제 입력 1 

```
5 10
baekjoononlinejudge
startlink
codeplus
sundaycoding
codingsh
baekjoon
star
start
code
sunday
coding
cod
online
judge
plus
```

### 예제 출력 1 

```
7
```

***

### 풀이

문자열 M과 이진탐색한 문자열 N과의 접두사 관계를 확인한다.

문제에서 문자열 S의 접두사란 S의 가장 앞에서부터 부분 문자열을 의미한다.

</br>

일단 집합 S를 정렬한다. 그러면 집합 S는 'a...', 'b...', 'c...'  ...  'g...' 이런 식으로 정렬 될 것이다.

</br>

그리고 각 문자열 M에 대하여 left = 0, right = N-1, mid = right / 2로 정의하고 탐색을 시작한다.

일단 처음에 S[mid]가 문자열 M을 접두사로 갖는지 확인한다. 이것이 참이면

해당 문자열 M은 집합 S에 포함되어있는 문자열들중 적어도 하나의 문자열에서 접두사가 되는 것이므로 정답 개수를 하나 증가시키고 탐색을 종료한다.

</br>

만약 S[mid]가 문자열 M보다 작다면 문자열 M이 접두사가 될 수 있는 어떤 문자열 N은 집합 S에서 mid보다 오른쪽에 있다는 것이다.

그래서 이때 left = mid + 1로 바뀌고 mid는 또 그 새로운 구간의 중앙값으로 바꾼다. mid =  (left + right) / 2

</br>

S[mid]가 문자열 M보다 크다면 문자열 M이 접두사가 될 수 있는 어떤 문자열 N은 집합 S에서 mid보다 왼쪽에 있다는 것이다.

그래서 이때 right = mid - 1로 바뀌고 mid는 또 그 새로운 구간의 중앙값으로 바꾼다. mid =  (left + right) / 2

</br>

탐색은 left가 right 이하일 동안만 계속 진행한다.

그리고 문자열 비교함수의 시간복잡도에 따라 O(N x logN) 이상의 시간복잡도가 될 것이다.

***

### 정리 내용

그런데 문제 풀이중 정리할 내용이 있었다.

일단 c의 strcmp(s1, s2), strncmp(s1, s2, 길이) 등에서 결과 값이 문자열 비교에 따라  < 0 (s1 < s2), 0 (s1 == s2), > 0 (s1 > s2) 이라는 것이다.

</br>

그리고 c의 qsort의 compare에서 아래와 같은 확인 사항이 있다. (문자열들간의 정렬)

```c
int compare_arr(const void* arg1, const void* arg2)
{
	return strcmp((char*)arg1, (char*)arg2);
}
/*
2차원 배열의 경우 넘어온 arg1, arg2가 문자열의 주소들이다.
그래서 그냥 바로 비교를 하면 된다.
*/


int compare_ptr1(const void* arg1, const void* arg2)
{
	return strcmp(*(char**)arg1, *(char**)arg2);
}

int compare_ptr2(const void** arg1, const void** arg2)
{
	return strcmp((char*)*arg1, (char*)*arg2);
}
/*
그러나 2차원 포인터 배열의 경우 arg1, arg2는 문자열의 주소가 아니라
문자열의 주소를 담고 있는 포인터의 주소이다
그래서 compare_ptr처럼 작성을 해야 한다.
1, 2의 차이는 매개변수를 바로 이중포인터로 받냐 안받냐인데
2차원 포인터 배열을 넘겨 받으므로 바로 2차원 포인터 형태로 받는게 더 직관적이고 일반적이지 않은가 싶은데
마이크로소프트의 설명서 에서는 1차원 포인터 형태로 받은 후에 다시 2차원 포인터 형태로 형변환을 해준 후 값에 접근하고 있다.
왜 그러는지는 모르겠는데 뭔가 이유가 있겠지 싶다. 아무튼 1, 2둘 중 아무렇게나 해도 된다.
*/
```















