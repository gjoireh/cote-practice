### 문제

문자열 S의 접두사란 S의 가장 앞에서부터 부분 문자열을 의미한다. 예를 들어, S = "codeplus"의 접두사는 "code", "co", "codepl", "codeplus"가 있고, "plus", "s", "cude", "crud"는 접두사가 아니다.

총 N개의 문자열로 이루어진 집합 S가 주어진다.

입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 문자열 중 적어도 하나의 접두사인 것의 개수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 문자열의 개수 N과 M (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000)이 주어진다. 

다음 N개의 줄에는 집합 S에 포함되어 있는 문자열이 주어진다.

다음 M개의 줄에는 검사해야 하는 문자열이 주어진다.

입력으로 주어지는 문자열은 알파벳 소문자로만 이루어져 있으며, 길이는 500을 넘지 않는다. 집합 S에 같은 문자열이 여러 번 주어지는 경우는 없다. 

### 출력

첫째 줄에 M개의 문자열 중에 총 몇 개가 포함되어 있는 문자열 중 적어도 하나의 접두사인지 출력한다.

### 예제 입력 1 

```
5 10
baekjoononlinejudge
startlink
codeplus
sundaycoding
codingsh
baekjoon
star
start
code
sunday
coding
cod
online
judge
plus
```

### 예제 출력 1 

```
7
```

***

### 풀이



첫 풀이는 브루트 포스라고 해야할지, 모든 문자열 M에 대하여 모든 문자열 N과의 접두사 관계를 확인한다.

문제에서 접두사의 의미는  '문자열 S의 접두사란 S의 가장 앞에서부터 부분 문자열' 이다.

그리고 하나의 M이 여러 N의 문자열에서 접두사가 될 수도 있겠지만 접두사의 개수를 세는 것이므로 그런 경우에도 1개만 세고 넘어가야 한다.

strncmp의 시간복잡도가 어떻게 될지는 모르겠지만 일단 이것을 제외 하고 최대 M x N, O(N^2)의 시간복잡도를 가질 것이므로

총 시간복잡도는 strncmp의 시간복잡도에 따라 O(N^2) 이상의 무언가가 될 것 같다.

그런데 파이썬 풀이 같으면 문자열 비교는 신경 안쓰고 그냥 O(N^2)이라고 했을 것 같다.

문자열 비교가 이렇게 strncmp같이 따로 함수로 있는게 아니라 그냥 사칙연산하듯이 자연스러우니까..  

  

그리고 이진탐색 풀이는 모든 문자열 M에 대하여 이진탐색한 문자열 N과의 접두사 관계를 확인한다.

이진탐색을 이용해서 모든 N과의 접두사 관계를 확인할 것을 일부 N과의 관계 확인으로 줄이는 것이다.



일단 집합 S를 먼저 정렬한다. 그러면 집합 S는 'a...', 'b...', 'c...'  ...  'g...' 이런 식으로 정렬 될 것이다.



그리고 각 문자열 M에 대하여 left = 0, right = N-1, mid = right / 2로 정의하고 탐색을 시작한다.

일단 처음에 S[mid]가 문자열 M을 접두사로 갖는지 확인한다. 이것이 참이면

해당 문자열 M은 집합 S에 포함되어있는 문자열들중 적어도 하나의 문자열에서 접두사가 되는 것이므로 정답 개수를 하나 증가시키고 탐색을 종료한다.

만약 S[mid]가 문자열 M보다 작다면 문자열 M이 접두사가 될 수 있는 어떤 문자열 N은 집합 S에서 mid보다 오른쪽에 있다는 것이다.

그래서 이때 left = mid + 1로 바뀌고 mid는 또 그 새로운 구간의 중앙값으로 바꾼다. mid =  (left + right) / 2

S[mid]가 문자열 M보다 크다면 문자열 M이 접두사가 될 수 있는 어떤 문자열 N은 집합 S에서 mid보다 왼쪽에 있다는 것이다.

그래서 이때 right = mid - 1로 바뀌고 mid는 또 그 새로운 구간의 중앙값으로 바꾼다. mid =  (left + right) / 2

탐색은 left가 right 이하일 동안만 계속 진행한다.

그리고 이것 역시 문자열 비교함수의 시간복잡도에 따라 O(N x logN) 이상의 시간복잡도가 될 것이다.

***

### 정리 내용

그런데 문제 풀이와 별도로 정리할 내용이 생겼다.

일단 c의 strcmp, strncmp 등에서 결과 값이 문자열 비교에 따라  < 0, 0, > 0 이라는 것이다.



그리고 c의 qsort에서 문자열을 정렬의 compare에서 아래와 같은 확인 사항이 있다.

```c
int compare_arr(const void* arg1, const void* arg2)
{
	return strcmp((char*)arg1, (char*)arg2);
}
/*
2차원 배열의 경우 넘어온 arg1, arg2가 문자열의 주소들이다.
그래서 그냥 바로 비교를 하면 된다.
*/


int compare_ptr1(const void* arg1, const void* arg2)
{
	return strcmp(*(char**)arg1, *(char**)arg2);
}

int compare_ptr2(const void** arg1, const void** arg2)
{
	return strcmp((char*)*arg1, (char*)*arg2);
}
/*
그러나 2차원 포인터 배열의 경우 arg1, arg2는 문자열의 주소가 아니라
문자열의 주소를 담고 있는 포인터의 주소이다
그래서 compare_ptr처럼 작성을 해야 한다.
1, 2의 차이는 매개변수를 바로 이중포인터로 받냐 안받냐인데
2차원 포인터 배열을 넘겨 받으므로 바로 2차원 포인터 형태로 받는게 더 직관적이고 일반적이지 않은가 싶은데
마이크로소프트의 설명서 에서는 1차원 포인터 형태로 받은 후에 다시 2차원 포인터 형태로 형변환을 해준 후 값에 접근하고 있다.
왜 그러는지는 모르겠는데 뭔가 이유가 있겠지 싶다. 아무튼 1, 2둘 중 아무렇게나 해도 된다.
*/
```















