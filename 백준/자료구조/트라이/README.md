### 트라이 자료구조 (접두사 찾기)

이전에 이진탐색에서 풀었던 문제인데

다른 사람의 제출 코드를 살펴 보다가 신기해 보이는 풀이가 있어서 살펴 보다가

트라이 라는 자료구조를 알게 되었다.

문자열을 빠르게 찾는데 용이한 자료구조 라는것 같다.

트라이에 대한 설명은 [여기](https://hwan-shell.tistory.com/133) 잘 되어 있는것 같다.

</br>

만약 like, bike, bool, book 이라는 문자열을 저장한다고 하면

![](./트라이.png)

와 같은 형태로 저장되는 자료구조이다.

저 그래프에서의 한 노드는 다음과 같은 형태로 정의하면 된다.

```C
typedef struct Node
{
	int child[26];
	bool end;
}NODE;
```



child[26]은 어떤 노드 다음에 올 수 있는 글자가 26개이므로 어떤 글자가 다음 노드에 오는지를 저장하기 위한 배열이다.

정확히는 child의 인덱스가 해당 문자열이 a로부터 몇번째에 위치한 글자인지를 나타내고 거기에 저장되는 값은 트라이 노드 배열의 인덱스,

즉 다음 노드의 인덱스 값이다.

</br>

end는 그 노드가 문자열의 끝임을 의미한다.

그런데 노드는 총 몇개가 필요할까?

이거를 잘 모르겠다. 제출한 사람마다 노드 배열의 크기를 다들 다르게 설정해 놨고

인터넷에서는 최대로 필요한 노드의 개수가 문자열의 길이 * 문자열의 개수 가 된다고 말하는 곳도 있는데

문자열의 길이 * 문자열의 개수 만큼의 노드가 필요하다면 이거는 그냥 직사각형 형태의 배열에 문자열이 저장되는 형태가 아닌가 싶다.

저렇게 트리 구조로 저장이 되면 분명 문자열 별로 공유하는 글자들이 생겨서 필요한 노드 개수가 줄어들 것 같다.

어쨌든 지금은 정확히 몇개가 필요할지 잘 모르겠다.

</br>

제출한 사람 중에는 문자열의 최대 개수 10000개 * 문자열의 최대 길이 500 이런식으로 설정한 사람도 있고

3000002, 30001 으로 한 사람이 있었다.  그냥 다들 나름대로 적당하게 정한걸까?

문자열의 최대 개수 * 문자열의 최대 길이는 위에서 얘기한것처럼 이렇게까지는 필요 없을 것 같고

궁금한게 3백만 2와 3만1인데 이런 수들이 어떤 결과로 나온 것인지가 궁금하다.

어쨋든 지금은 잘 모르겠고 질문도 할 수 가 없으니 일단 나는 30000정도로 하면 좋을 것 같다.

</br>

트리에 저장하는 add 함수는

노드 번호, 문자열, 문자열의 인덱스를 인자로 받는다.

재귀이고 종료 조건은 인덱스가 문자열의 길이와 같아졌을때이다.

각 알파벳이 a로부터 몇번째에 위치하는지를 결정하고 그 값을 현재 트라이 노드의 child의 인덱스로 사용한다.

그 위치에 아무것도 저장되어 있지 않다면 다음 노드 번호를 하나 만들어서 거기에 저장한다.

저장되어 있는 값(어떤 노드의 인덱스)가 있다면 그것을 사용한다. 이것이 다음 노드 번호가 된다.

이것을 모든 입력받은 문자열에 대하여 진행한다.

```C
void add(int node, char* s, int index) //node0 is root
{
	int c, next, child;

	if (index == ssize)
	{
		trie[node].end = true;
		return;
	}

	c = s[index] - 'a';
	if (trie[node].child[c] == 0)
	{
		next = init();
		trie[node].child[c] = next;
	}

	child = trie[node].child[c];
	add(child, s, index + 1);
}

int main()
{
    
    ...
        
	for (i = 0; i < N; i++)
	{
		scanf("%s", s);
		for (j = 0; s[j] != '\0'; j++);
		ssize = j;
		add(0, s, 0);
	}
}
```

</br>

search함수도 노드 번호, 문자열, 문자열 인덱스를 인자로 받는다.

마찬가지로 재귀이고, (여기서 search와 add가 둘다 위치만 다른 동일한 작업을 하고 있기 때문에 재귀가 적절하다고 할 수 있을 것이다.)

종료 조건은 문자열의 인덱스가 문자열의 크기와 같아졌을때 이다.

search도 어떤 노드에서 문자열의 어떤 글자가 a로부터 얼마나 떨어진 위치에 있는지 확인하고

현재 노드의 child 배열에서 그 위치에 저장된 값을 확인 하는데 이것이 0이면 원하는 문자열 탐색에 실패한 것이다.

여기서 끝나지 않으면 계속 다음을 진행한다.

그러다가 문자열의 인덱스가 문자열의 크기와 같아진다면(이때까지 모든 글자가 트리 안에 있었다면)

이것은 이 문자열이 트리 안에 저장된 어떤 문자열의 접두사가 된다는 의미가 된다.

```C
int search(int node, char* s, int index)
{
	int c, child;

	if (index == ssize) return 1;

	c = s[index] - 'a';
	child = trie[node].child[c];
	if (child == 0) return 0; //node0 is root

	return search(child, s, index + 1);
}

int main()
{
    ...
    for (i = 0; i < M; i++)
	{
		scanf("%s", s);
		for (j = 0; s[j] != '\0'; j++);
		ssize = j;
		res += search(0, s, 0);
	}    
}

```

대충 이런 식으로 진행이 되는데 너무 어렵다.

어쩌다 들여다 봐서 살펴 보긴 했는데 지금 내가 보고 있을만한 것이 아닌 것 같다.

