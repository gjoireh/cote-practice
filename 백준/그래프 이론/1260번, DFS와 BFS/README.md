## 1260번 DFS와 BFS



#### 걸림이 됐던 것들

1. 많이 반복되는 입력이 있을 때 input() 대신  sys.stdin.readline() 사용

   ```python
   import sys
   sys.stdin.readline()
   ```

   

2. BFS에서 큐를 리스트 말고 덱을 사용하도록 한다

   ```python
   from collections import deque
   ```

   3.  정확한 말인지는 확실하지 않은데 그래프가 트리 모양일때와 그렇지 않을때

      DFS, BFS 구현에서 차이가 있을 수 밖에 없는 것 같다.

      그래프가 트리 모양이면 스택이나 큐에 이전에 저장했던 노드가 또 저장될 일이 없다

      그런데 트리 모양이 아니면 이전에 저장했던 노드를 또 스택, 큐에 저장하게 된다

      이를테면 이 문제에서처럼

      1 : [2, 3, 4]

      2 : [1, 4]

      3 : [1, 4]

      4 : [1, 2, 3]

      이런식으로 연결이 되어있는 그래프가 있다고 하면 1을 스택에 저장했다가

      방문 = []

      스택 = [1]

      

      이것을 빼고 이것에 연결된 노드들중 방문하지 않은 노드인 2, 3, 4를 저장할 것이다 문제에서 작은 번호부터 방문하라고 해서 여기서 연결된 노드 2, 3, 4를 반대로 저장한다

      방문 = [1]

      스택 = [4, 3, 2]

      

      다음 방문지인 2번을 방문하고 2번에 연결된 1,4중에서 방문하지 않은 노드인 4를 추가할 것이다.

      방문 = [1, 2]

      스택 = [4, 3, 4]

      

      ?

      4가 두번 들어갔다. 그래프 모양에 따라서 두번, 세번 몇번이고 들어갈수 있을 것이다

      이러면 방문 리스트도 당연히 동일한 장소를 몇번씩 반복하는 이상한 경로가 되어버린다.

      어쨋든 계속 진행해 본다.

      


      이제 다음 방문지인(스택에 있는 마지막 요소) 4번 노드에 방문하고 4번에 연결된 1,2,3중 방문하지 않은 3을 추가한다

      방문 = [1, 2, 4]

      스택 = [4, 3, 3]

      

      또 다음 방문지인(스택에 있는 마지막 요소) 3번 노드에 방문하고 3번에 연결된 1,4중 방문하지 않은 노드는 없으므로 스택에 더 추가하지는 않는다.

      방문 = [1, 2, 4, 3]

      스택 = [4, 3]

      

      이러면 이제 모든 노드를 방문했으므로 탐색이 끝나야 하는데 스택에 4,3이 남아있기에 탐색이 더 진행되고 방문했던 4, 3에 또 방문하게 된다.

      

      그래서 스택, 큐에 저장된 노드를 빼서 현재 노드변수에 넣고 그 값이 방문 리스트에 있는지를 확인해서 방문한적이 있다면 continue로 넘어가서 계속 새로 뽑게 했다.

      

    4.  그리고 주어지는 시작 노드에 아무것도 연결되는 노드가 없는 경우,

       이런 경우에는 그 노드에 연결된 인접 노드들을 찾는 부분에서 오류가 날수밖에 없다

       그래서 인접노드 찾는 부분으로 넘어가기 전에 그 노드가 그래프에 있는지를 확인 해야한다.

       그래프를 저장할때 아무런 연결이 없는 노드는 저장을 안했기 때문에

       그 노드가 그래프에 없다면 그것은 아무런 연결이 없는 노드라고 생각할 수 있고 그러면 더 진행하지 않고 거기서 끝내면 된다.

       

       