### 스타트와 링크

***

### 문제

오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다. 축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이고 신기하게도 N은 짝수이다. 이제 N/2명으로 이루어진 스타트 팀과 링크 팀으로 사람들을 나눠야 한다.

BOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다. 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다.

N=4이고, S가 아래와 같은 경우를 살펴보자.

| i\j  | 1    | 2    | 3    | 4    |
| :--- | :--- | :--- | :--- | :--- |
| 1    |      | 1    | 2    | 3    |
| 2    | 4    |      | 5    | 6    |
| 3    | 7    | 1    |      | 2    |
| 4    | 3    | 4    | 5    |      |

예를 들어, 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우에 두 팀의 능력치는 아래와 같다.

- 스타트 팀: S12 + S21 = 1 + 4 = 5
- 링크 팀: S34 + S43 = 2 + 5 = 7

1, 3번이 스타트 팀, 2, 4번이 링크 팀에 속하면, 두 팀의 능력치는 아래와 같다.

- 스타트 팀: S13 + S31 = 2 + 7 = 9
- 링크 팀: S24 + S42 = 6 + 4 = 10

축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다.

### 입력

첫째 줄에 N(4 ≤ N ≤ 20, N은 짝수)이 주어진다. 둘째 줄부터 N개의 줄에 S가 주어진다. 각 줄은 N개의 수로 이루어져 있고, i번 줄의 j번째 수는 Sij 이다. Sii는 항상 0이고, 나머지 Sij는 1보다 크거나 같고, 100보다 작거나 같은 정수이다.

### 출력

첫째 줄에 스타트 팀과 링크 팀의 능력치의 차이의 최솟값을 출력한다.

### 예제 입력 1

```
4
0 1 2 3
4 0 5 6
7 1 0 2
3 4 5 0
```

### 예제 출력 1

```
0
```

### 예제 입력 2 

```
6
0 1 2 3 4 5
1 0 2 3 4 5
1 2 0 3 4 5
1 2 3 0 4 5
1 2 3 4 0 5
1 2 3 4 5 0
```

### 예제 출력 2

```
2
```

### 예제 입력 3

```
8
0 5 4 5 4 5 4 5
4 0 5 1 2 3 4 5
9 8 0 1 2 3 1 2
9 9 9 0 9 9 9 9
1 1 1 1 0 1 1 1
8 7 6 5 4 0 3 2
9 1 9 1 9 1 0 9
6 5 4 3 2 1 9 0
```

***

### 풀이

N명이 주어졌을때 N / 2 명씩으로 팀을 만드는 모든 경우를 구한다.

그 모든 경우에서 문제에서 말하는 대로 팀의 능력치를 구하고 두 팀의 능력치의 차를 구한다.

그 차 중에 최소값을 출력한다.

</br>

여기서 문제는 어떻게 N / 2 명으로 만들 수 있는 모든 팀을 확인할 것인가 이다.

for를 쓰려고 한다면

```python
N = 4
# N = 4면
# 팀원 수는 두명씩 될 것이다.
# 그러면 2중 for문으로 모든 팀의 경우를 구할 수 있다.
for i in range(N):
    for j in range(i+1, N):
        print(i, j)

N =  6
# N = 6이라면
# 팀원 수는 3명씩이 될 것이다.
# 그러면 모든 팀의 경우를 확인하기 위해 3중 for문을 사용해야한다.
for i in range(N):
    for j in range(i + 1, N):
        for k in range(j +1, N):
            print(i,j,k)
```

이렇게 N의 값에 따라 수행해야 하는 for문이 중첩되는 수가 달라져야 하기 때문에 for로는 매번 N의 값에 따라 대응할 수 없다.

그러므로 모든 팀의 경우를 확인하기 위해 재귀함수로 팀을 만들어야 한다.

</br>

N명을 일렬로 쭉 세워놨다고 할때

만들어질수 있는 모든 팀의 경우를 확인하는 것이 목표이기 때문에

재귀함수는 그 N명을 처음부터 끝까지 한명 한명 확인하며

현재의 사람에 대하여 팀1에도 넣어보고 팀2에도 넣어봐야 한다.

</br>

그리고 N명을 다 돌았을때 팀1과 팀2가 각각 N / 2명씩으로 구성이 되었다면 팀이 완성된 것으로 판단한다. (재귀함수 종료 조건)

팀이 완성 되었다면 그 두 팀의 능력치 차를 구하고 저장해 놓는다.(저장해 놓던가 매번 최소값을 갱신 하던가)

그리고 팀이 이루어 졌든 안이루어 졌든간에 현재의 사람(인덱스)에 대하여 팀 구성 작업이 끝났다면

그 사람이 팀에서 그 위치에 배치된 후에 올 수 있는 모든 경우에 대한 작업은 끝난 것 이므로 팀에서 해당 사람을 빼야한다.

이렇게 하면 만들 수 있는 모든 팀을 확인하는 재귀함수가 된다.

</br>

그리고 팀1과 팀2 둘중에 하나라도 N / 2를 넘어 섰는데 팀이 완성된 것으로 판단되지 않았다면

이것은 계속 진행 해봐야 팀1과 팀2가 각각 N / 2명씩으로 구성될 수가 없다. 이것을 확인하여 불필요한 계산을 줄인다.

(이런식으로 브루트 포스에서 어떤 조건으로 가지수를 줄이는 것을 백트래킹이라고 한다고 한다.)

</br>

그리고 문제의 답은 재귀함수에서 팀이 만들어 질때마다 두 팀의 능력치 차를 구했기 때문에 그 중에 최소를 출력하면 된다.

</br>

</br>

그런데 한가지 확인할만한 사항이 있었다.

```python
def make_team(index, t1, t2):
    if index == N:
        if len(t1) == N // 2 and len(t2) == N // 2:
            return True
        else:
            return False

    if stop(t1, t2):
        return False

    t1.append(index)
    if make_team(index + 1, t1, t2):
        save_diff(t1, t2)
    t1.pop()

    t2.append(index)
    if make_team(index + 1, t1, t2):
        save_diff(t1, t2)
    t2.pop()
```

python에서는 make_team() 함수에서 index == N인 경우에만 반환값이 있어도

```python
if make_team(index + 1, t1, t2):
        save_diff(t1, t2)
```



이런 식으로 재귀호출 할 때 문제 되는 것이 없다. 의도한 대로 오직 팀이 N / 2, N / 2 명씩 구성 됐을때만 팀의 능력치 차이를 계산한다.

그런데 

```c++
bool make_team(int index, vector<int>& t1, vector<int>& t2)
{
	if (index == N)
	{
		if (t1.size() == N / 2 and t2.size() == N / 2)return true;
		else return false;
	}

	if (stop(t1, t2))return false;

	t1.push_back(index);
	if (make_team(index + 1, t1, t2))get_diff(t1, t2);
	t1.pop_back();

	t2.push_back(index);
	if (make_team(index + 1, t1, t2))get_diff(t1, t2);
	t2.pop_back();

}
```

C++에서는 문제가 된다. 여기서 index가 N이 아닌 경우에는 반환값이 없다.
이때 무언가 false가 아닌 것이 나와서 팀이 완성되었는지 확인하는 부분에서 완성된 것으로 판단하고 그 후로 넘어간다.
(index == N 이고 t1.size() == N / 2 and t2.size() == N / 2일때가 팀이 완성된 때인데 이 외에도 항상 1이나오므로 팀이 완성된 때를 구분하지 못하게 된다)  

```C++
if (make_team(index + 1, t1, t2))get_diff(t1, t2);
```
  
함수에서 반환 값을 정했고 index == N 외의 경우에 반환값이 없으니
index == N 외의 경우에도 당연히 반환값을 지정해 줘야 할 것이다.

```c++
...
return false
```




같은 부분에서 의도한대로 동작하지 않는다.

