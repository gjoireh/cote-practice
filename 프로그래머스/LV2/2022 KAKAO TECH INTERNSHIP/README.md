### 문제
***
[링크](https://school.programmers.co.kr/learn/courses/30/lessons/118667)

### 풀이
***
문제에서 중요한 점은 두가지였던것 같다  
```
1. 어떻게 최소 작업 횟수를 찾을것인지
2. 어떻게 각 큐의 합을 같게 만들 방법이 없다고 단정 지을 것인지
```

처음에 두 큐의 각 원소들의 합을 같아지게  
하는 원소들의 이동 조합을 찾으려고 했었는데 이것은 어리석다  

어떻게 조합을 찾았다고 해도 결국에는 문제에서 요구하는대로 작업횟수, 그러니까  
그 찾은 수들이 이동하기 위해 발생하는 작업 횟수를 모두 확인해야 한다  
그리고 무엇보다 시간복잡도를 절대 통과하지 못한다  
</br>

어떻게 최소 작업 횟수를 찾을 수 있을지 한참 생각했다   
이것은  
* 두 큐의 총합의 평균값 (목표값)
* 문제에서 원소들의 이동 방법이 큐의 앞으로 나가서 뒤로 들어온다는 식으로 지정되어 있다는 점
  
에서 어느정도 착안할 수 있다  

큐에서 원소가 들어오고 나가는 방법이 지정되어 있기 때문에  
각 큐의 원소들의 합을 목표값을 향해 원소를 빼고 넣고 하다가  
큐 원소들의 합이 목표값에 이르면 그때까지의 작업 횟수가 최소 작업 횟수이다  

</br>

이를테면  

1번 큐에서 원소들의 합이 목표값보다 작다면  
1번큐의 합이 목표값이 될 때까지 2번큐의 원소를 1번큐로 이동시킨다  
반대의 경우도 마찬가지다  

이렇게 진행 하면 두 큐의 합을 같게 만들 수 없는 경우가 아니라면  
무조건 두 큐의 합이 같아지는 순간이 나타난다  
그때까지의 작업 횟수가 문제에서 요구하는 최소 작업 횟수이다  

그러면 
```
1번. 어떻게 최소 작업 횟수를 찾을 것인가
```
는 해결 되었고  

```
2번. 어떻게 각 큐의 합을 같게 만들 방법이 없다고 단정 지을 것인가?
```
가 남아 있다  

여기서 또 한참을 헤맸다  

일단 몇가지 떠올랐던것은  
1. 두 큐의 총 합이 홀수인 경우
2. 두 큐의 원소들 중에 가장 큰 원소가 나머지 모든 원소들의 합보다 큰 경우
3. 어떻게 원소들을 이동하다 보니 이동을 시작했던 처음 상태로 돌아왔다?  
   또 똑같은 이동을 반복하게 생겼다? 하는 무한 쯔꾸요미같은 상황인 경우

들이다  

1,2번은 3번에 포함된다  
실제로 1,2번은 구현 안해도 통과하는데는 문제가 없다  
그래도 3번의 작업을 다 진행하지 않게 해주는 백트래킹같은 효과는 낼것이다  


3번은 주어진 두 큐의 각 합을 같게 만들 수 없다고 단정할만한 조건으로 보인다  
이것을 다음과같이 나타낼 수 있다  

</br>
  
각 큐의 합을 같게 맞추기 위해 원소들이 이리저리 이동하는 와중에  
```
어느 한쪽 큐에서 다른쪽 큐로 원소를 보내는 행위를
처음 큐의 길이의 두배만큼 수행했는데 각 큐의 합이
목표값(두 큐 총합의 평균)에 이르지 못했다
```  

이것은 무한 츠쿠요미의 시작을 의미한다  
  
2번 큐가 가진 모든것을 1번 큐로 보낸 후  
1번 큐가 처음에 가지고 있던 모든 것을 2번 큐로 받은 후에    
그것을 또 2번큐에서 1번큐로 모두 보냈는데 목표값에 이르지 못한 것이다  

이것은 완전히 처음 상태로 돌아가기 전 상황이고 큐의 합들이  
목표값에 이르지 못했기 때문에 작업은 계속 진행될 것이다    
그리고 여기서 더 진행하면 완전히 처음 상황으로 돌아간다  
두 큐 각각의 합을 같게 할 수 없는 것이다  






  




