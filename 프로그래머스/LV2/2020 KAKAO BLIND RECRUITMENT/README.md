

### 문제

***

데이터 처리 전문가가 되고 싶은 **"어피치"**는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.
간단한 예로 "aabbaccc"의 경우 "2a2ba3c"(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, "abcabcdede"와 같은 문자열은 전혀 압축되지 않습니다. "어피치"는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.

예를 들어, "ababcdcdababcdcd"의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 "2ab2cd2ab2cd"로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 "2ababcdcd"로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.

다른 예로, "abcabcdede"와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 "abcabc2de"가 되지만, 3개 단위로 자른다면 "2abcdede"가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.

압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- s의 길이는 1 이상 1,000 이하입니다.
- s는 알파벳 소문자로만 이루어져 있습니다.

##### 입출력 예

| s                            | result |
| ---------------------------- | ------ |
| `"aabbaccc"`                 | 7      |
| `"ababcdcdababcdcd"`         | 9      |
| `"abcabcdede"`               | 8      |
| `"abcabcabcabcdededededede"` | 14     |
| `"xababcdcdababcdcd"`        | 17     |

### 입출력 예에 대한 설명

**입출력 예 #1**

문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다.

**입출력 예 #2**

문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다.

**입출력 예 #3**

문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다.

**입출력 예 #4**

문자열을 2개 단위로 자르면 "abcabcabcabc6de" 가 됩니다.
문자열을 3개 단위로 자르면 "4abcdededededede" 가 됩니다.
문자열을 4개 단위로 자르면 "abcabcabcabc3dede" 가 됩니다.
문자열을 6개 단위로 자를 경우 "2abcabc2dedede"가 되며, 이때의 길이가 14로 가장 짧습니다.

**입출력 예 #5**

문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.
따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다.
이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다.



***
### 풀이

처음에는 가장 짧게 압축되는 단위를 바로 찾는 방법이 없을까를 한참 생각했다.

그러다가 그거는 불가능할것 같아서 문자열을 1개 단위로, 2개 단위로 ... n개 단위로 압축한 모든 결과를 구하기로 했다.

그리고 n은 문자열 S의 절반이면 되리라고 생각 했다.

문자열 전체 길이의 절반을 넘어서는 수로는 반복이 될리가 없기 때문이다.  

</br>

그래서 문자열을 자르는 단위 수를 1 ~ 문자열 s의 길이 / 2 까지로 하고

각 경우의 압축된 문자열의 길이를 모두 저장한 후에 그 길이들 중의 최소값을 구했다.

```C++
for (int i = 1; i <= (s_length / 2); i++)
{
    lengths.push_back(compress(i, s).length());
}
answer = get_min(lengths);
return answer;
```

compress는 s를 i 단위로 압축하는 함수, get_min은 최소값 구하는 함수다.

</br>

그런데 이렇게 제출을 하면 5번테스트케이스에서만 실패를 하고 96점인가를 받는다.

별 문제가 없겠다고 생각 했지만서도 28개 테스트케이스중 27개가 잘 통과되는 것을 보고 놀랐다.

</br>

저 실패하는 케이스 하나가 뭘까 하고 생각하다가 모르겠어서 질문하기쪽을 찾아보니

파이썬으로 푼 사람중 누군가가

```python
for i in range(1, (s의 길이 / 2) + 1)
```

을

```python
for i in range(1, (s의 길이 / 2) + 2)
```

으로 바꿨더니 5번을 잘 넘어가더라는 글을 봤다.

</br>

그러니까 문자열을 압축하는 단위를 s의 절반보다 하나 큰 경우까지 진행을 한다는 것이다.

그런데 분명 s의 절반을 넘어가는 단위까지 압축을 시도할 필요는 없을 것이다.

그러면 저건 뭘까 하고 생각하다가 생각이 문자열의 길이가 1일때에 이르렀다.

</br>

문자열의 길이가 1인 경우에는 2로 나눴을때 0이되어 for문이 시작하지 않아서 문제가 될 것이다.

그리고 테스트케이스 5번은 문자열의 길이가 1인 케이스일 것이다. 테스트케이스를 그냥 보여주면 좋겠는데 안보여준다..

그래서 길이가 1인 경우를 따로 처리해주거나 문자열을 자르는 단위를 s의 절반 + 1까지로 설정하면 된다.

그런데 그 단 한번 있는 문자열 1인 경우를 위해서 다른 모든 경우에서 무의미한 s의 절반 + 1 단위 압축을 하는 것은 안좋다고 생각되어

1인 경우만 따로 처리 했다.

</br>

그런데 python의 경우 range가 마지막 요소를 포함하지 않기 때문에 python이라면 문자열 길이 1 뿐만 아니라 2, 3도 따로 처리를 해줘야 한다.

```python
for i in range(1,1//2):
for i in range(1,2//2):
for i in range(1,3//2):
```

1~3 모두 2로 나눴을때 1이 되어 마찬가지로 for문이 시작하지 않기 때문이다.

그래서 python으로 푼다면 그냥 따로 처리 안하고 for( + 2) 로 하는 것도 좋을 것 같다.

</br>

하지만 C/C++의 for는 마지막 요소를 <=과 같이 포함할수 있기 때문에 for에서 마지막 요소를 포함시켜 놓고

문자열의 길이가 1일 때만 처리해주는게 좋을 것 같다.

```C++
for (int i = 1; i <= (s_length / 2); i++)
{
...
}
```

</br>

compress는 문자열 s와 문자열을 압축할 단위를 매개변수로 받는다.

문자열 s의 인덱스 0에서 s의 절반-1 인덱스까지 이동하면서

i번째 인덱스에서 n만큼 뒤와 i+n번째 인덱스에서 n만큼 뒤를 비교한다.

```C++
if (s.substr(i, n) == s.substr(i+n, n))
```

</br>

이때 이것이 같다면 반복되는 요소를 i번째 인덱스에서 n만큼 뒤로 설정한다.

```C++
repeated = s.substr(i, n);
```

이 설정은 반복되는 요소가 여러개일때 처음 한번만 설정하고

여러번 반복되는 경우에는 그 반복되는 횟수만 계속 1씩 늘려 가며 저장 한다.

```C++
if (s.substr(i, n) == s.substr(i+n, n))
{
    if (cnt == 1)
    {
        repeated = s.substr(i, n);
    }
    cnt++;
}
```

</br>

i번째 인덱스에서 n만큼 뒤와 i+n번째 인덱스에서 n만큼 뒤를 비교해서 같지 않을때는

반복되던 단위가 있는 경우에 그것을 반복 횟수 + 반복 단위로 result에 추가하고

반복되던 단위가 없었다면 그냥 i번째 인덱스에서 n만큼 뒤만 result에 추가한다.

```C++
else
{
    if (cnt != 1)
    {
        result += to_string(cnt) + repeated;
        cnt = 1;
    }
    else
    {
        result += s.substr(i, n);
    }

}
```

</br>

그리고 i+n이 s의 길이 이상이 되는 경우에는

이제 더이상 n 단위로 반복되는 일이 없을 것이므로 

이때까지 반복되는 단위를 세던 것이 있으면 그것을 result에 추가하고

없었다면 i번째 이후의 것들을 모두 result에 추가한 후 종료 한다.

```C++
if ((i+n >= s.length()))
{
    if (cnt != 1)
    {
        result += to_string(cnt) + repeated;
    }
    else
    {
        result += s.substr(i);
    }

    break;
}
```

</br>

***

### 풀고 나서

레벨 2 문제도 만만치 않은 것 같다.

그래도 이정도만 되도 아예 못풀겠다는 아닌 것 같다.

그런데 실제 시험볼때는 이것보다 쉬운 문제도 뇌정지로 인해 풀기가 어렵다.

많이 연습 해야 할 것이다.

















