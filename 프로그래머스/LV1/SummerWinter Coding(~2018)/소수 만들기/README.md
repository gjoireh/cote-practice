### 문제

주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요.  
  
제한사항  
* nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.  
* nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.  

입출력 예

| nums      | 	result |
|-----------|---------|
| [1,2,3,4] | 	1      |
|[1,2,7,6,4]|	4|

입출력 예 설명  
입출력 예 #1  
[1,2,4]를 이용해서 7을 만들 수 있습니다.  

입출력 예 #2  
[1,2,4]를 이용해서 7을 만들 수 있습니다.  
[1,4,6]을 이용해서 11을 만들 수 있습니다.  
[2,4,7]을 이용해서 13을 만들 수 있습니다.  
[4,6,7]을 이용해서 17을 만들 수 있습니다.  
  
***
### 풀이
주어지는 nums의 숫자들 중에서 3개를 선택해서 더했을 때  
그것이 소수인 경우의 수를 구하라는 문제이다  
  
소수 판별 부분은 이전에 사용하던 것을 가져왔다  
이 소수판별은 약수의 성질을 이용하여 성능이 개선된 버전이다   
자기 자신보다 작은 수 1을 제외한 수 중에  
자신을 나누어 떨어지게 할 수 있는 수가 있다면 소수가 아니다  

그리고 모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭을 이루므로  
어떤 수의 제곱근(가운데 약수) 까지만 확인을 해보면 된다  
이 문제에서는 이렇게까지는 신경 안써도 될 것 같기는 하다  

나는 이 문제에서 N개의 수에서 M개를 뽑는 것에 집중하고 싶었다   
파이썬에 관련 라이브러리가 있는것으로 알지만    
재귀함수로 했던 방식을 연습하기 위해 재귀함수를 사용했다  
  
이전에 풀어봤던 문제중에 유사한 문제를 찾다가      
N과 M이라는 문제에서 N개중 M개를 뽑는 작업을 재귀함수로 한것을 확인 했다  
이것을 보고 유사하게 구현 했다  
  
여기서 재귀함수가 적절하다고 판단할 수 있는 근거는  
해야하는 작업이 주어진 숫자들을 탐색하면서    
어떤 숫자를 뽑냐 안뽑냐를 결정 하는 동일한 작업을 하고 있으며  
3개를 뽑는다 라는 종료 조건이 있다는 것이다  

3개의 자리를 만들어 놓고  

| 첫번째 자리 | 두번째 자리 | 세번째 자리 |
|--------|-----|-----|
| 1      | 2   | 7   |

(nums = [1,2,4,7])  
그 자리에 주어진 수들 중 어떤 수를 넣을것인가 말 것인가 하는  
동일한 작업을 반복하고 있다고도 할 수 있다  
  
그러므로 일단 재귀함수는 뽑을 대상이 되는 숫자들에 접근 가능해야한다(n, nums)  
재귀함수는 종료 조건을 알고 있어야한다(m)  
그리고 현재까지 몇개 뽑았는지를 알아야 한다(만들어놓은 3개 자리의 인덱스 라고도 할 수 있다)(cnt)  
그리고 어떤 숫자를 사용 했는지를 기록할 무언가도 있어야 한다(used)    
  
문제에서는 콤비네이션(조합)을 요구하고 있다  
재귀함수에서 뽑을 숫자를 탐색할 때 그 범위를 항상 주어진 수 전체로 삼으면 순열이 된다    
```python
# permutation
 def go(cnt, n, m, nums):
     global answer
     if cnt == m:
         if is_prime_number(sum(used)):
             answer += 1
         return

     for i in range(n):
         if nums[i] in used:
             continue
         used.add(nums[i])
         go(cnt + 1, n, m, nums)
         used.remove(nums[i])
```
숫자를 탐색할때 다음에 탐색할 범위를 현재 인덱스 다음부터 끝까지로 제한해야 조합이 된다  
```python
# combination
def go(j, cnt, n, m, nums):
    global answer
    if cnt == m:
        if is_prime_number(sum(used)):
            answer += 1
        return

    for i in range(j, n):
        if nums[i] in used:
            continue
        used.add(nums[i])
        go(i+1, cnt + 1, n, m, nums)
        used.remove(nums[i])
```  
이것은 일부 확인해보면 확인 가능하다    
이를테면 1,2,3,4 의 숫자가 주어졌을 때  
1,2,3 까지 간 후 재귀함수는 끝날 것이고  
used는 1,2 가 된 후 1,2,4 가 될 것이다  
그리고 또 1,2,4에서 재귀가 끝날 것이고  
1,3 으로 넘어갈 것이다  
이때 탐색 범위가 숫자 전체라면  1,3,2를 뽑게된다(탐색범위 전체에서 1은 used에 있으므로 넘어가고 2는 없으므로 추가한다)    
이것은 이전에 뽑은 123과 같은 조합이다  
그래서 조합을 원한다면 다음 탐색 범위를 현재의 인덱스 다음~끝 까지로 제한해야한다    










