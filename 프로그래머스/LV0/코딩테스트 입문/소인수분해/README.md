어떤 수 n을 소인수분해 한다면  
n을 나누어 떨어지게 하는 어떤 소수로 n을 안나눠질때까지 쭉 나누고    
그 다음 또 나누어지는 어떤 수로 또 반복하고... 하는 과정을 n이 1이 될 때까지 한다  

</br>

n을 2로 나누기 시작해서  
현재 나누고 있는 수가 n을 나누어 떨어지게 한다면  
현재 나누고 있는 수로 n을 계속 나눈다  

```python
def solution(n):
    i = 2
    ans = []
    while n > 1:
        if n % i == 0:
            ans.append(i)
            while n % i == 0:
                n //= i
        i += 1
    return ans
```
n을 2로 나누어지지 않을때까지 계속 나눌 것이기 때문에  
진행 하다가 나중에 가서 갑자기 n이 4로 나눠진다던가 할 일이 없다  
이런 점에서 2부터 차례대로 나눠보기 시작한다면 n이 소수가 아닌 수로 나눠지는 상황은 걱정하지 않아도 된다  

2로 나눠지는게 끝났다면 3, 4(2로 다 나눈 후라 4로 안나눠질테니 4같은건 그냥 넘어가게 된다), 5,  
6(3으로 다 나눈 후라 6으로 안나눠지니까 6같은건 그냥 넘어가게 된다) ...  로 n 나누기를 n이 1이 될 때까지 계속 반복한다  

당연히 n 이하의 소수를 모두 확인하고 그중에 약수를 찾는 방식보다 훨씬 좋다  
내 풀이는 어리석다  




